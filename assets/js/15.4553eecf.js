(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{437:function(e,t,r){"use strict";r.r(t);var a=r(65),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[e._v("#")]),e._v(" 概念")]),e._v(" "),r("p",[e._v("官网描述：本质上，"),r("code",[e._v("webpack")]),e._v(" 是一个现代 JavaScript 应用程序的静态模块打包器("),r("code",[e._v("module bundler")]),e._v(")。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图("),r("code",[e._v("dependency graph")]),e._v(")，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 "),r("code",[e._v("bundle")])]),e._v(" "),r("p",[e._v("《深入浅出webpack》：Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的 Loader 去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。")]),e._v(" "),r("p",[e._v("个人理解：将前端应用程序（"),r("code",[e._v("vue, typescript, less...")]),e._v("）打包压缩为一个浏览器可运行的代码程序（"),r("code",[e._v("html, css, JavaScript")]),e._v("）")]),e._v(" "),r("h4",{attrs:{id:"参考文档地址"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考文档地址"}},[e._v("#")]),e._v(" 参考文档地址")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://webpack.docschina.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack中文官网"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"http://webpack.wuhaolin.cn/",target:"_blank",rel:"noopener noreferrer"}},[e._v("深入浅出 Webpack"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=n.exports}}]);